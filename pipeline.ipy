# This files contains all pipeline
# Make sure run this with ipython
# Make sure you have docker installed

# !pip3 install pyyaml numpy pandas biopython
import os
import yaml
from pprint import pprint
import argparse

# Commmand line parameters
parser = argparse.ArgumentParser(description="Pipeline of quantification of de-novo assembly")
parser.add_argument("--method",       type=str, default="all",  help="What step you want to run. Default: all.")
parser.add_argument("-t", "--thread", type=int, default=32,     help="Threads")
parser.add_argument("-m", "--memory", type=int, default=300,    help="Memory")
parser.add_argument("--meta",         type=str, default="metadata/meta.yaml", help="The path of metadata")
parser.add_argument("--base",         type=str, default="data", help="The path to store your data")
args = parser.parse_args()

# init
data = yaml.load(open(args.meta))
thread = args.thread
memory = args.memory
base_folder = args.base
%alias dk docker run -it --rm --security-opt label=disable -v $PWD:/app -w /app %s


def download():
    """
    Download data from ensembl and ncbi

    Output
    ------
    reference genome:       data/{species}/download/genome.fasta
    reference transcripts:  data/{species}/download/transcriptome.fasta
    reference annotation:   data/{species}/download/annotation.gff
    experiment fastq file:  data/{species}/xx.fastq
    """
    for species in data['species']:
        meta = data['species'][species]
        data_folder = f"{base_folder}/{species}/download"
        exp_project = ["explow", "exphigh"]
        !mkdir -p {data_folder}

        # download sequences and annotation from Ensembl
        !wget {meta['ref_genome']} -O {data_folder}/genome.fasta.gz
        !wget {meta['ref_transcriptome']} -O {data_folder}/transcriptome.fasta.gz
        !wget {meta['ref_annotation']} -O {data_folder}/annotation.gff.gz

        # Download fastq from ncbi
        !echo '/LIBS/GUID = "7509f4a9-59b3-4305-85a3-e5a140183031"' > /tmp/tmp.mkfg
        for proj in exp_project:
            for id in meta[f'{proj}_sraid']:
                %dk -v /tmp/tmp.mkfg:/root/.ncbi/user-settings.mkfg:ro {data['images']['sratool']} \
                        fastq-dump --defline-seq '@$sn[_$rn]/$ri' --split-files {id} -O {data_folder}

        # unzip all
        !gzip -d {data_folder}/*.gz

        # merge and rename
        for proj in exp_project:
            fastqs_r1 = ' '.join([os.path.join(data_folder, id + "_1.fastq") for id in meta[f'{proj}_sraid']])
            fastqs_r2 = ' '.join([os.path.join(data_folder, id + "_2.fastq") for id in meta[f'{proj}_sraid']])
            !cat {fastqs_r1} > {data_folder}/../{proj}_r1.fastq
            !cat {fastqs_r2} > {data_folder}/../{proj}_r2.fastq


def prepareReference():
    """
    Filter out short and mito mrna from gnome and transcriptome and
    Prepare data for simulation

    All files have prefix 'data/{species}/'

    Inputs
    ------
    The references data downloaded from web
        * download/genome.fasta
        * download/transcriptome.fasta
        * download/annotation.gff

    Outputs
    -------
    Filtered mrna transcriptome data
        * chromosome.fasta
        * mRNA.gtf
        * mRNA.fasta

    The files for simulation
        * simulation/chromosome/*.fasta
        * simulation/flux_simulator.gtf
        * simulation/flux_simulator_clean.gtf
    """

    from pipelines.utils import mRNAFilter
    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        mRNAFilter(data_folder,
                   refdir=f"{data_folder}/download",
                   simdir=f"{data_folder}/simulation",
                   shortest_length=data['species'][species]['mrna_min_length'])

        # TODO: I don't know what it is
        awk_query = '\'BEGIN{FS="\t";OFS="\t"}{split($NF,a," ");pfx="";s="";for(i=1;i<=length(a);i+=2){if(a[i]=="transcript_id"){pfx=a[i]" "a[i+1]}else{s=s" "a[i]" "a[i+1]}}if(pfx==""){print "[WARN] line "NR" without transcript_id!" > "/dev/stderr"}else{$NF=pfx""s;print$0} }\''
        !awk {awk_query} {data_folder}/simulation/flux_simulator.gtf > {data_folder}/simulation/flux_simulator_clean.gtf


def simulation():
    """
    Simulate the reads sequencing from transcriptome.fasta

    All files have prefix 'data/{species}/'

    Inputs
    ------
    * simulation/chromosome/*.fasta
    * simulation/flux_simulator.gtf
    * simulation/flux_simulator_clean.gtf
    * metadata/flux_simulator_*.par
    * metadata/flux_simulator_*.pro

    Outputs
    -------
    Simulation output:  simulation/*
    Reads data:         xx_r1.fastq, xx_r2.fastq
    """
    from pipelines.utils import splitInterleavedReads
    for species in data['species']:
        for ds in data['datasets']:
            if not ds.startswith("sim"):
                continue

            data_folder = f"{base_folder}/{species}/simulation"
            file_simulation = data['species'][species][ds + '_file']
            !cp {file_simulation}* {data_folder}
            basename = os.path.basename(file_simulation)
            print("Simulate", basename)

            # simulation
            %dk {data['images']['fluxsimulator']} \
                flux-simulator --threads {thread} -p {data_folder}/{basename}.par -l -s

            # split reads
            splitInterleavedReads(f"{data_folder}/{basename}.fastq", f"{data_folder}/../{proj}")


def fastqc():
    """
    Fastqc(Inspect reads quality)

    Inputs
    ------
    Reads data: data/{species}/xx.fastq

    Outputs
    -------
    FastQC output: data/{species}/fastqc/
    """
    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        !mkdir -p {data_folder}/fastqc

        %dk {data['images']['fastqc']} \
            fastqc -t {thread} -f fastq -o {data_folder}/fastqc {data_folder}/*.fastq



def trimmomatic():
    """
    Trimmomatic(Remove low quality reads)

    Inputs
    ------
    Reads data: data/{species}/xx.fastq

    Outputs
    -------
    Trimmed reads data: data/{species}/xx.trim.fastq
    Trimmomatic output: data/{species}/trimmed/
    """
    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        !mkdir -p {data_folder}/trimmed
        for ds in data['datasets']:
            basename = f"{data_folder}/{ds}"
            basename_trim = f"{data_folder}/trimmed/{ds}"
            print("Trim", basename)

            %dk {data['images']['trimmomatic']} \
                trimmomatic PE -threads {thread} -phred33 -trimlog {basename_trim}.log \
                {basename}_r1.fastq {basename}_r2.fastq \
                {basename}_r1.trim.fastq {basename_trim}_r1.unpaired.fastq \
                {basename}_r2.trim.fastq {basename_trim}_r2.unpaired.fastq \
                SLIDINGWINDOW:4:20 MINLEN:30


def assemble():
    """
    Assemble reads to transcriptome
    Three methods are used:
        trinity, rnaspades, transabyss

    Inputs
    ------
    Reads data: data/{species}/xx_r{1,2}.trim.fastq

    Outputs
    -------
    Assembled sequences: data/{species}/xx.{assemble_method}.fasta
    """
    from pipelines.utils import fasta_length_filter

    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        for ds in data['datasets']:
            # create soft link to mRNA sequences
            basename = f"{data_folder}/{ds}"
            !ln -s mRNA.fasta {basename}.mRNA.fasta

            # Run all assemble methods
            for method in data['assemble']:
                # TODO check: Using different strand when proceed mouse data with experiment fastq
                if ds.startswith("exp") and species == "mouse":
                    strand_trinity = "--SS_lib_type RF"
                    strand_transabyss = "--SS"
                    strand_rnaspades = "--ss-rf"
                else:
                    strand_trinity = ""
                    strand_transabyss = ""
                    strand_rnaspades = ""

                image = data['images'][method]
                min_len = data['assemble'][method]['minlen']
                base_assemble_folder = f"{data_folder}/{method}"
                !mkdir -p {base_assemble_folder}

                # trinity
                if method == "trinity":
                    %dk {image} \
                        Trinity --max_memory {memory}G --CPU {thread} --seqType fq {strand_trinity} --min_contig_length {min_len} \
                        --left {basename}_r1.trim.fastq --right {basename}_r2.trim.fastq --output {base_assemble_folder}
                    !cp {base_assemble_folder}/Trinity.fasta {basename}.trinity.fasta
                    !rm -rf {base_assemble_folder}

                # rnaspades
                elif method == "rnaspades":
                    %dk -u root {image} \
                        rnaspades.py -t {thread} -m {memory} {strand_rnaspades} \
                        -1 {basename}_r1.trim.fastq -2 {basename}_r2.trim.fastq -o {base_assemble_folder}
                    fasta_length_filter(f"{base_assemble_folder}/transcripts.fasta", f"{basename}.rnaspades.fasta", min_len)
                    !rm -rf {base_assemble_folder}

                # transabyss
                elif method == "transabyss":
                    %dk {image} bash -c "ln -s /usr/local/bin/ /usr/local/lib/python3.8/site-packages/bin && \
                            transabyss --threads {thread} --length {min_len} {strand_transabyss} \
                            --pe {basename}_r1.trim.fastq {basename}_r2.trim.fastq --outdir {base_assemble_folder}/log"

                    !cp {base_assemble_folder}/transabyss-final.fa {basename}.transabyss.fasta
                    !rm -rf {base_assemble_folder}

                else:
                    print("error")


def quantification(reference=True):
    """
    Transcriptome Quantification

    Parameters
    ----------
    reference: bool, default = True
        Run quantification on mRNA(reference).

    Inputs
    ------
    Assembled sequences: data/{species}/xx.{method_assemble}.fasta
    Reads: data/{species}/xx_r{1,2}.fastq

    Outputs
    -------
    Abundance tsv: data/{species}/xx.{method_assemble}.{method_quantify}.tsv
    """
    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        for ds in data['datasets']:
            ori_seq = f"{data_folder}/{ds}"
            # TODO check: Using different strand when proceed mouse data with experiment fastq
            if ds.startswith("exp") and species == "mouse":
                strand_kallisto = "--rf-stranded"
                strand_rsem = "reverse"
                #SS_SALMON="-l ISR"
            else:
                strand_kallisto = ""
                strand_rsem = "none"

            for method_assemble in [*data['assemble'], "mRNA"]:
                if method_assemble == "mRNA" and not reference:
                    continue

                whole_seq = f"{data_folder}/{ds}.{method_assemble}.fasta"
                for method_quant in data['quant']:
                    image = data['images'][method_quant]
                    data_quant_folder = f"{base_folder}/{species}/{method_quant}"
                    name = f"{ds}.{method_assemble}.{method_quant}"
                    !mkdir -p {data_quant_folder}

                    # kallisto
                    if method_quant == "kallisto":
                        %dk {image} \
                            kallisto index -i {data_quant_folder}/{name}.index -k {data['quant'][method_quant]['kmer']} {whole_seq}
                        %dk {image} \
                            kallisto quant -i {data_quant_folder}/{name}.index -t {thread} {strand_kallisto} \
                                 -o {data_quant_folder} {ori_seq}_r1.fastq {ori_seq}_r2.fastq
                        !mv {data_quant_folder}/abundance.tsv {data_folder}/{name}.tsv

                    # rsem
                    elif method_quant == "rsem":
                        %dk {image} \
                            rsem-prepare-reference -p {thread} --bowtie2 {whole_seq} {data_quant_folder}/{name}.index
                        %dk {image} \
                            rsem-calculate-expression --strandedness {strand_rsem} -p {thread} --bowtie2 --time --paired-end  \
                                {ori_seq}_r1.fastq {ori_seq}_r2.fastq {data_quant_folder}/{name}.index {data_quant_folder}/{name}
                        !mv {data_quant_folder}/{name}.isoforms.results {data_folder}/{name}.tsv

                    # salmon
                    elif method_quant == "salmon":
                        %dk {image} \
                            salmon index -i {data_quant_folder}/{name}.index -t {whole_seq} --type quasi \
                                -k {data['quant'][method_quant]['kmer']}
                        %dk {image} \
                            salmon quant -i {data_quant_folder}/{name}.index -p {thread} -l A \
                                -1 {ori_seq}_r1.fastq -2 {ori_seq}_r2.fastq -o {data_quant_folder}
                        !mv {data_quant_folder}/quant.sf {data_folder}/{name}.tsv


def answerExp():
    """
    Generate answer to experiments fastq.

    Averaging tpm from three quantification methods
    (All mapped to mRNA) are set as answer.

    Inputs
    ------
    Quantification tsv files: data/{species}/xx.mRNA.{method_quant}.tsv

    Outputs
    -------
    Answer tsv files: data/{species}/xx.mRNA.answer.tsv
    """
    from pipelines.utils import average_tpm
    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        for ds in data['datasets']:
            if not ds.startswith("exp"):
                continue
            files = {method_quant: f"{data_folder}/{ds}.mRNA.{method_quant}.tsv"
                        for method_quant in data['quant']}
            average_tpm(files, f"{data_folder}/{ds}.mRNA.answer.tsv")


def answerSim():
    """
    Generate answer to simulation fastq.

    Inputs
    ------
    Quantification tsv files: data/{species}/xx.mRNA.{method_quant}.tsv
    Simulation data: data/{species}/simulation/xx.pro
    Simulation data: data/{species}/simulation/xx.lib
    unparied reads: data/{species}/trimmed/simlow_r1.unpaired.fastq

    Outputs
    -------
    Answer tsv files: data/{species}/xx.mRNA.answer.tsv
    """
    from pipelines.utils import reference_tpm

    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        for ds in data['datasets']:
            if not ds.startswith("sim"):
                continue
            name_simulation = os.path.basename(data['species'][species][ds + '_file'])
            file_pro = f"{data_folder}/simulation/{name_simulation}.pro"
            file_lib = f"{data_folder}/simulation/{name_simulation}.lib"
            file_unpaired = [f"{data_folder}/trimmed/{ds}_r1.unpaired.fastq",
                             f"{data_folder}/trimmed/{ds}_r2.unpaired.fastq"]
            reference_tpm(file_pro, file_lib, file_unpaired, f"{data_folder}/{ds}.mRNA.answer.tsv")


def blastSelf():
    """
    Self blast assembled transcriptome

    Input
    -----
    Assembled sequences: data/{species}/xx.{method_assemble}.fasta
    mRNA : data/{species}/mRNA.fasta

    Output:
    Blast data: data/{species}/blast
    Blast self result: data/{species}/{ds}.{method_assemble}.blast.self.tsv
    Blast mrna to contig result: data/{species}/{ds}.{method_assemble}.blast.mrna_to_contig.tsv
    Blast contig to mrna result: data/{species}/{ds}.{method_assemble}.blast.contig_to_mrna.tsv
    """
    for species in data['species']:
        # mrna database
        data_folder = f"{base_folder}/{species}"
        mrna_seq = f"{data_folder}/mRNA.fasta"
        mrna_blast = f"{data_folder}/blast/mRNA"
        !mkdir -p {data_folder}/blast
        %dk {data['images']['blast']} \
            makeblastdb -in {mrna_seq} -dbtype nucl -out {mrna_blast}

        for ds in data['datasets']:
            for method_assemble in data['assemble']:
                # mrna database
                assembled_seq = f"{data_folder}/{ds}.{method_assemble}.fasta"
                assembled_blast = f"{data_folder}/blast/{ds}.{method_assemble}"
                blast_name = f"{data_folder}/{ds}.{method_assemble}.blast"
                %dk {data['images']['blast']} \
                    makeblastdb -in {assembled_seq} -dbtype nucl -out {assembled_blast}

                # blast self
                %dk {data['images']['blast']} \
                    blastn -db {assembled_blast} -query {assembled_seq} -outfmt 6 -out {blast_name}.self.tsv \
                    -evalue {data['blast']['evalue']} -perc_identity {data['blast']['identity']}
                # blast mrna to contig
                %dk {data['images']['blast']} \
                    blastn -db {assembled_blast} -query {mrna_seq}      -outfmt 6 -out {blast_name}.mrna_to_contig.tsv
                # blast contig to mrna
                %dk {data['images']['blast']} \
                    blastn -db {mrna_blast}      -query {assembled_seq} -outfmt 6 -out {blast_name}.contig_to_mrna.tsv


def checkAssembleQuality():
    """
    Check assembled transcriptome quality by Transrate

    Inputs
    ------
    Assembled sequences: data/{species}/xx.{method_assemble}.fasta

    Outputs
    -------
    Transrate Output:
    """
    for species in data['species']:
        data_folder = f"{base_folder}/{species}"
        transrate_folder = f"{data_folder}/transrate"
        !mkdir -p {transrate_folder}
        for ds in data['datasets']:
            ori_seq = f"{data_folder}/{ds}"
            for method_assemble in [*data['assemble'], "mRNA"]:
                assembled_seq = f"{data_folder}/{ds}.{method_assemble}.fasta"
                %dk {data['images']['transrate']} \
                    transrate --assembly {ori_seq}.{method_assemble}.fasta --threads {thread} \
                    --output {transrate_folder}/{ds}.{method_assemble} \
                    --left {ori_seq}_r1.fastq --right {ori_seq}_r2.fastq
                ! mv {transrate_folder}/{ds}.{method_assemble}/{ds}.{method_assemble}/contigs.csv \
                     {data_folder}/{ds}.{method_assemble}.transrate.csv


# main
if args.method in ["all", "download"]:
    download()
if args.method in ["all", "simulation"]:
    prepareReference()
    simulation()
if args.method in ["all", "fastqc"]:
    fastqc()
if args.method in ["all", "trim"]:
    trimmomatic()
if args.method in ["all", "assemble"]:
    assemble()
if args.method in ["all", "quantify"]:
    quantification(reference=True)
if args.method in ["all", "answer"]:
    answerExp()
    answerSim()
if args.method in ["all", "postassemble"]:
    blastSelf()
    checkAssembleQuality()

# ipython pipeline.ipy -- --method=quantify
